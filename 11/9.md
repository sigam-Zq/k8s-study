Task


为用户工作负载创建一个名为 high-priority 的新PriorityClass ,其值比用户定义的现有最高优先级类小一。


修补在 priority namespace 中运行的现有的 busybox-logger Deployment ,以使用 high-priority 优先级别类。


确保busybox-logger Deployment在设置了新优先级类后成功部署


>  priority namespace 中运行的其他的deplpoyment 的pod 预计被逐出




我将帮您创建一个新的 PriorityClass 并更新 busybox-logger Deployment。以下是完整的步骤：

## 步骤 1：检查现有的 PriorityClass

首先，我们需要查看当前存在的用户定义的 PriorityClass，找到最高优先级值：

```bash
# 获取所有 PriorityClass，按值排序
kubectl get priorityclass -o custom-columns=NAME:.metadata.name,VALUE:.value,GLOBAL-DEFAULT:.globalDefault --sort-by=.value
```

## 步骤 2：创建 high-priority PriorityClass

假设我们找到的最高用户定义优先级值为 `X`，那么我们需要创建值为 `X-1` 的 PriorityClass。

创建文件 `high-priority-class.yaml`：

```yaml
apiVersion: scheduling.k8s.io/v1
kind: PriorityClass
metadata:
  name: high-priority
value: 1000000  # 替换为实际计算出的值 (最高优先级值 - 1)
description: "High priority class for user workloads"
globalDefault: false
preemptionPolicy: PreemptLowerPriority
```

例如，如果最高优先级值是 `1000001`，那么：

```yaml
apiVersion: scheduling.k8s.io/v1
kind: PriorityClass
metadata:
  name: high-priority
value: 1000000
description: "High priority class for user workloads"
globalDefault: false
preemptionPolicy: PreemptLowerPriority
```

应用这个 PriorityClass：

```bash
kubectl apply -f high-priority-class.yaml
```

## 步骤 3：更新 busybox-logger Deployment

修补 busybox-logger Deployment 以使用新的 PriorityClass：

```bash
kubectl patch deployment busybox-logger -n priority -p '{
  "spec": {
    "template": {
      "spec": {
        "priorityClassName": "high-priority"
      }
    }
  }
}'
```

## 步骤 4：验证更新

```bash
# 检查 Deployment 状态
kubectl get deployment busybox-logger -n priority

# 查看 Pod 状态
kubectl get pods -n priority -l app=busybox-logger

# 检查 Pod 是否使用了正确的 PriorityClass
kubectl describe pod -n priority -l app=busybox-logger | grep "Priority Class"

# 查看 Pod 事件，确认是否有驱逐发生
kubectl get events -n priority --sort-by='.lastTimestamp'
```

## 步骤 5：监控 Pod 驱逐

由于设置了更高的优先级，其他低优先级的 Pod 可能会被驱逐：

```bash
# 查看 priority namespace 中所有 Pod 的状态
kubectl get pods -n priority

# 查看是否有 Pod 被驱逐
kubectl get pods -n priority | grep Evicted

# 查看详细的驱逐事件
kubectl get events -n priority --field-selector reason=Evicted
```

## 完整示例

假设当前最高用户定义的 PriorityClass 值为 `1000001`，完整的创建和更新过程：

```bash
# 1. 创建 high-priority PriorityClass
cat <<EOF | kubectl apply -f -
apiVersion: scheduling.k8s.io/v1
kind: PriorityClass
metadata:
  name: high-priority
value: 1000000
description: "High priority class for user workloads"
globalDefault: false
preemptionPolicy: PreemptLowerPriority
EOF

# 2. 更新 Deployment
kubectl patch deployment busybox-logger -n priority -p '{
  "spec": {
    "template": {
      "spec": {
        "priorityClassName": "high-priority"
      }
    }
  }
}'

# 3. 等待部署完成
kubectl rollout status deployment/busybox-logger -n priority

# 4. 验证
kubectl get pods -n priority -o wide
```

## 重要说明

1. **优先级值计算**：新 PriorityClass 的值必须比现有最高用户定义的 PriorityClass 小 1
2. **Pod 驱逐**：由于设置了更高的优先级，busybox-logger Pod 可能会抢占资源，导致其他低优先级 Pod 被驱逐
3. **PreemptionPolicy**：设置为 `PreemptLowerPriority` 允许抢占低优先级 Pod
4. **验证成功**：确保 busybox-logger Deployment 成功部署并运行新的 Pod

完成这些步骤后，busybox-logger Deployment 将使用新的 high-priority PriorityClass，并且由于其更高的优先级，可能会驱逐 priority namespace 中的其他低优先级 Pod。