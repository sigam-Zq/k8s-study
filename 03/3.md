# ConfigMap

```sh
cat game.properties

#configmap from file
kubectl create configmap game-config --from-file=game.properties
kubectl create configmap game-env-config --from-env-file=game.properties
kubectl get configmap -oyaml game-config
```

## ConfigMap from literal

```sh
kubectl create configmap special-config --from-literal=special.how=very --from-literal=special.type=charm
#downward api pod
kubectl create -f downward-api-pod.yaml
kubectl get po downward-api-pod
kubectl logs -f downward-api-pod
```

创建对应pod后查看内部环境变量的现象


### 问
当前环境变量已经进入pod环境 zq102@MSI MINGW64 /d/desktop/gitDemo/k8s/03 $ k exec downward-api-pod -- echo $SPECIAL_LEVEL_KEY (base) zq102@MSI MINGW64 /d/desktop/gitDemo/k8s/03 $ k exec downward-api-pod -- env |grep SPECIAL_LEVEL_KEY SPECIAL_LEVEL_KEY=very (base) 

但是分别执行上述的命令 为什么第一种拿不到pod内部的环境变量 但是第二种方法可以拿到

### 回答
非常棒的问题 👍，你这个现象其实是很多人第一次用 `kubectl exec` 时都会遇到的。

你的两条命令分别是：

```bash
# 第一条
kubectl exec downward-api-pod -- echo $SPECIAL_LEVEL_KEY

# 第二条
kubectl exec downward-api-pod -- env | grep SPECIAL_LEVEL_KEY
```

结果是：

* 第一条 **输出为空**；
* 第二条 **输出正确（very）**。

---

## 🌟 根本原因：变量展开的位置不同

### ✅ 1. 第一条命令：变量在 **本地 Shell（主机上）** 被展开了

当你在本地执行：

```bash
kubectl exec downward-api-pod -- echo $SPECIAL_LEVEL_KEY
```

这里的 `$SPECIAL_LEVEL_KEY` 会被 **你本地终端的 shell（比如 bash、zsh、MINGW64）先行解析**。

也就是说，在 `kubectl exec` 执行之前，本地的 shell 就已经把 `$SPECIAL_LEVEL_KEY` 替换掉了。

* 如果你本地环境没有定义这个变量（通常没有），它就变成了空字符串。
* 所以最终实际执行的命令是：

  ```bash
  kubectl exec downward-api-pod -- echo
  ```

  → 输出为空。

---

### ✅ 2. 第二条命令：`env | grep SPECIAL_LEVEL_KEY` 是在 Pod 内部执行的

```bash
kubectl exec downward-api-pod -- env | grep SPECIAL_LEVEL_KEY
```

这里 `$SPECIAL_LEVEL_KEY` 没有在本地 shell 中出现。
整个 `env | grep SPECIAL_LEVEL_KEY` 字符串会被 **直接传给容器里的 shell 执行**。

容器里的 shell 再执行 `env`，所以能正确看到容器内部环境变量。

---

## 💡 解决方法（想让 echo 也能正确）

要避免本地 shell 先行展开 `$SPECIAL_LEVEL_KEY`，可以用引号或转义：

### ✅ 方法 1：单引号 `'...'`

```bash
kubectl exec downward-api-pod -- sh -c 'echo $SPECIAL_LEVEL_KEY'
```

> 单引号会告诉本地 shell 不要替换 `$` 符号，而让它传到容器中去。

### ✅ 方法 2：转义 `$`

```bash
kubectl exec downward-api-pod -- sh -c "echo \$SPECIAL_LEVEL_KEY"
```

这两种效果一样，容器内执行时才会展开变量，结果：

```
very
```

---

## 🧠 总结对比

| 命令                                              | 变量在哪里展开                 | 结果        |    |
| ----------------------------------------------- | ----------------------- | --------- | -- |
| `k exec pod -- echo $SPECIAL_LEVEL_KEY`         | **本地 Shell**            | 为空        |    |
| `k exec pod -- env                              | grep SPECIAL_LEVEL_KEY` | **容器内执行** | 正确 |
| `k exec pod -- sh -c 'echo $SPECIAL_LEVEL_KEY'` | **容器内执行**               | 正确        |    |

---

✅ **结论：**

> `$` 是 Shell 变量展开符，默认由你当前执行命令的 Shell 处理。要让它在容器内解析，就要用引号包裹或转义。

---

是否希望我再帮你总结几种常见的 `kubectl exec` 变量展开陷阱与正确写法？（比如多行命令、管道命令、变量传递等）

### 尝试

```

zq102@MSI MINGW64 /d/desktop/gitDemo/k8s/03
$ k exec downward-api-pod -- sh -c 'echo $SPECIAL_LEVEL_KEY'
very
(base) 
zq102@MSI MINGW64 /d/desktop/gitDemo/k8s/03
$ k exec downward-api-pod -- sh -c "echo $SPECIAL_LEVEL_KEY"

(base) 
zq102@MSI MINGW64 /d/desktop/gitDemo/k8s/03
$ k exec downward-api-pod -- sh -c "echo \$SPECIAL_LEVEL_KEY"
very
```